*tagalong.txt*	Change an HTML(ish) opening tag and take the closing one along, too

==============================================================================
CONTENTS                                        *tagalong*   *tagalong-contents*

    Installation................................: |tagalong-installation|
    Usage.......................................: |tagalong-usage|
    Internals...................................: |tagalong-internals|
    Settings....................................: |tagalong-settings|
    Issues......................................: |tagalong-issues|


==============================================================================
INSTALLATION                                            *tagalong-installation*

The easiest way to install the plugin is with a plugin manager:

- vim-plug: https://github.com/junegunn/vim-plug
- Vundle:   https://github.com/VundleVim/Vundle.vim

If you use one, just follow the instructions in its documentation.

You can install the plugin yourself using Vim's |packages| functionality by
cloning the project (or adding it as a submodule) under
`~/.vim/pack/<any-name>/start/`. For example:
>
    git clone https://github.com/AndrewRadev/tagalong.vim ~/.vim/pack/_/start/tagalong
<
This should automatically load the plugin for you on Vim start. Alternatively,
you can add it to `~/.vim/pack/<any-name>/opt/` instead and load it in your
.vimrc manually with:
>
    packadd tagalong
<
If you'd rather not use git, you can download the files from the "releases"
tab and unzip them in the relevant directory:
https://github.com/AndrewRadev/tagalong.vim/releases.


==============================================================================
USAGE                                                          *tagalong-usage*

The plugin is designed to automatically rename closing HTML/XML tags when
editing opening ones (or the other way around). For the most part, you should
be able to edit your code normally (see below for limitations) and the plugin
would take care of the renaming once you leave insert mode.

Apart from HTML tags, it'll also detect XML-style `<namespaced:tags>`,
react-style `<Component.Subcomponents>`, ember-style `<component/paths>`.

The plugin only activates for HTML-like buffers, or at least all the ones that
I could think of. You can see the full list in the setting
|g:tagalong_filetypes|. You can use that variable to change the list, add
support for more filetypes, or only keep the ones you use. (Consider opening
an issue to suggest changes to the default list.) See the "Settings" section
for details.

Requirements ~

The plugin requires the built-in "matchit" plugin, but it takes care to load
it, if it isn't already. If, for some reason, it can't be loaded, this plugin
will silently not work, to avoid problems with minimal installations. You can
learn more about matchit by executing `:help matchit`.

Features and Limitations ~

Not every method of changing the tag can be intercepted, or it might be too
complicated or too invasive to do so. Here's the methods that work with the
plugin:

- `c`: Anything involving a `c` operation, including `cw`, `ci<`, `cE`, or `C`.
- `v` + `c`: Selecting anything in visual mode and changing it with a `c`.
- `i`, `a`: Entering insert mode and making direct changes.

For all of these, the cursor needs to be within the `<>` angle brackets of the
tag. If you change it from the outside, like with a `C` starting at the
opening angle bracket, the plugin won't be activated.

A few examples of making a change that WON'T trigger the plugin:

- Using the `:substitute` command, for instance `:%s/<div /<span /g`.
- Yanking some text and pasting it over.
- Using the `r` or `x` mappings to change/delete one character.

Some of these might be implemented at a later time, but others might be too
difficult or too invasive. If you often use a method that doesn't trigger the
plugin, consider opening a github issue to discuss it.

Also note that the plugin relies on the |InsertLeave| autocommand to detect
when to apply the change. If you exit insert mode via <c-c>, that won't be
triggered. This is a good way to avoid the automatic behaviour, but if you
commonly exit insert mode this way, it can be a problem. See
|tagalong-internals| for help.

You can disable the plugin for particular mappings by overriding the
|g:tagalong_mappings| variable. See |tagalong-settings| for details.

If you have vim-repeat (https://github.com/tpope/vim-repeat) installed, you
can repeat the last tag change with the |.| operator.


==============================================================================
SETTINGS                                                     *tagalong-settings*

                                                          *g:tagalong_filetypes*
>
    let g:tagalong_filetypes = ['html']
<
Default value: [
    'html', 'xml', 'jsx', 'eruby', 'ejs', 'eco', 'php', 'htmldjango'
]

This variable holds all of the filetypes that the plugin will install mappings
for. If, for some reason, you'd like to avoid its behaviour for particular
markup languages, you can set the variable to a list of the ones you'd like to
keep.

If you'd like to add values to this list, you have to ensure the plugin is
loaded first, and then modify that variable. For instance, by using |:runtime|:
>
    runtime plugin/tagalong.vim
    call add(g:tagalong_filetypes, 'custom')
    call add(g:tagalong_filetypes, 'another')
<
You could also achieve this via |:packadd| -- the important thing is that the
setting is initialized.

If you set it to an empty list, `[]`, the plugin will not be automatically
installed for any filetypes, but you can activate it yourself by calling
the `tagalong#Init()` function in a particular buffer.

                                                           *g:tagalong_mappings*
>
    let g:tagalong_mappings = ['i', 'a']
<
Default value: ['c', 'C', 'v', 'i', 'a']

This setting controls which types of editing will have mappings installed for
them. Currently, these are literal mappings -- each character in the list is a
mapping that you can see by executing `:nmap c`, for instance. But it's not
necessary to be the case -- in the future, the values in the list might be
labels of some sort that will be explained in more detail in the
documentation.

Changing this variable means that editing the buffer with the removed mappings
won't trigger the plugin. You could set it to `['i', 'a']` if you usually edit
tags by entering insert mode and backspacing over the tag. That way, the `c`
family of mappings could be used as an escape hatch, if the plugin bugs out or
you have good reason not to update the other tag.

Note that the plugin will attempt to respect your previous mappings of any of
these keys. If you have an `nnoremap c` in your `.vimrc` file, it'll be
applied. Mapping `cw`, on the other hand, will likely just use your mapping,
instead of hitting the plugin at all. If you're having problems with this,
please open a github issue.

If you set the variable to an empty list, `[]`, the plugin will not be
activated by any mappings, but you can read the |tagalong-internals| section
for some advanced ways of using it.

                                                            *g:tagalong_verbose*
>
    let g:tagalong_verbose = 1
<
Default value: 0

If you set this value to 1, the plugin will print out a message every time it
auto-updates a closing/opening tag. Could be useful if you'd like to be sure
the change was made, especially if it's offscreen.


==============================================================================
INTERNALS                                                   *tagalong-internals*

The plugin installs its mappings with the function `tagalong#Init()`. All
mappings and variables initialized are buffer-local. Instead of using
|g:tagalong_filetypes|, you can actually just put `tagalong#Init()` in
`~/.vim/ftplugin/<your-filetype>.vim`, and it should work. Or you can come up
with some other criteria to activate it.

All the mappings (currently) do the following:

- Call the `tagalong#Trigger()` function. It stores information about the tag
  under the cursor in a buffer-local variable.

- Execute the original mapping.

- Upon exiting insert mode (see |InsertLeave|), the function
  `tagalong#Apply()` gets called, takes the stored tag information and gets
  the changed tag and applies the change to both opening and closing tag

- The `tagalong#Reapply()` function can be invoked by vim-repeat, or it can be
  invoked manually, to perform the previous tag change.

So, if you wanted to make pasting over a tag activate the plugin, it might work like this:
>
    " The `<c-u>` removes the current visual mode, so a function can be called
    xnoremap <buffer> p :<c-u>call <SID>Paste()<cr>

    " The <SID> above is the same as the s: here
    function! s:Paste()
        call tagalong#Trigger()

        " gv reselects the previously-selected area, and then we just paste
        normal! gvp

        call tagalong#Apply()
    endfunction
<
This is not a built-in, because it feels a bit invasive, and there's other
plugins (and snippets) that override |p|. Plus, repeating the operation
doesn't seem to quite work. But I hope it's a good example to illustrate how
you could try to build something more complicated with the core functions of
the plugin.

If you commonly exit insert mode via `<c-c>`, the plugin won't be triggered,
but you can take care of that with a mapping, if you'd like:
>
    inoremap <silent> <c-c> <c-c>:call tagalong#Apply()<cr>
<
It's generally not recommended -- `<c-c>` doesn't trigger |InsertLeave|
semi-intentionally, I think, as an "escape hatch". But it depends on how you
use it.


==============================================================================
ISSUES                                                         *tagalong-issues*

Any issues and suggestions are very welcome on the github bugtracker:
https://github.com/AndrewRadev/tagalong.vim/issues


vim:tw=78:sw=4:ft=help:norl:
